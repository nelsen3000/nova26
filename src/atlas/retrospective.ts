// Kronos Retrospective - ATLAS agent uses Kronos for pattern analysis
// Phase 3: Analyze build history, detect patterns, generate improvement proposals

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { KronosClient } from './kronos-client.js';
import type { KronosPointer } from './types.js';
import type { BuildLog } from '../types/index.js';

const ATLAS_DIR = join(process.cwd(), '.nova', 'atlas');
const BUILDS_FILE = join(ATLAS_DIR, 'builds.json');

export interface EffectivePattern {
  name: string;
  description: string;
  agent: string;
  occurrences: number;
  lastSeen: string;
}

export interface FailurePattern {
  name: string;
  description: string;
  agent: string;
  occurrences: number;
  severity: 'low' | 'medium' | 'high';
}

export interface AgentStats {
  agent: string;
  totalTasks: number;
  passedTasks: number;
  failedTasks: number;
  successRate: number;
  avgDuration: number;
}

export interface Retrospective {
  generatedAt: string;
  project: string;
  totalBuilds: number;
  agentStats: AgentStats[];
  effectivePatterns: EffectivePattern[];
  failurePatterns: FailurePattern[];
  kronosPointers: KronosPointer[];
  recommendations: string[];
}

export class KronosRetrospective {
  private kronos: KronosClient;

  constructor(kronosBaseUrl?: string) {
    this.kronos = new KronosClient(kronosBaseUrl);
  }

  /**
   * Generate a full retrospective from build history + Kronos memory.
   * Combines file-based builds.json analysis with Kronos semantic search.
   */
  async generateRetrospective(project: string): Promise<Retrospective> {
    const builds = this.loadBuilds();
    const agentStats = this.computeAgentStats(builds);
    const effectivePatterns = this.detectEffectivePatterns(builds);
    const failurePatterns = this.detectFailurePatterns(builds);

    // Query Kronos for deeper semantic patterns (best-effort)
    let kronosPointers: KronosPointer[] = [];
    try {
      const isHealthy = await this.kronos.healthCheck();
      if (isHealthy) {
        const failedAgents = agentStats
          .filter(s => s.successRate < 1.0)
          .map(s => s.agent);

        if (failedAgents.length > 0) {
          const query = `failure patterns for agents: ${failedAgents.join(', ')}`;
          const result = await this.kronos.search(query, project);
          kronosPointers = result.pointers;
        }

        // Also search for general improvement opportunities
        const improvementResult = await this.kronos.search(
          'improvement opportunities slow duration retry failed',
          project
        );
        kronosPointers = [...kronosPointers, ...improvementResult.pointers];
      }
    } catch {
      // Kronos context is optional for retrospectives
    }

    const recommendations = this.generateRecommendations(agentStats, effectivePatterns, failurePatterns);

    const retro: Retrospective = {
      generatedAt: new Date().toISOString(),
      project,
      totalBuilds: builds.length,
      agentStats,
      effectivePatterns,
      failurePatterns,
      kronosPointers,
      recommendations,
    };

    // Save retrospective to atlas directory
    this.saveRetrospective(retro);

    return retro;
  }

  /**
   * Generate a pre-task briefing for a specific agent based on history.
   * This is what ATLAS feeds to agents before they start a new task.
   */
  async generateBriefing(agent: string, taskDescription: string, project: string): Promise<string> {
    const builds = this.loadBuilds();
    const agentBuilds = builds.filter(b => b.agent === agent);

    let briefing = `# Pre-Task Briefing for ${agent}\n\n`;
    briefing += `**Generated by:** ATLAS retrospective engine\n`;
    briefing += `**Date:** ${new Date().toISOString()}\n\n`;

    // Agent track record
    const passed = agentBuilds.filter(b => b.gatesPassed).length;
    const total = agentBuilds.length;
    if (total > 0) {
      briefing += `## Agent Track Record\n\n`;
      briefing += `- **Tasks completed:** ${total}\n`;
      briefing += `- **Success rate:** ${((passed / total) * 100).toFixed(0)}%\n`;
      const avgDur = agentBuilds.reduce((sum, b) => sum + b.duration, 0) / total;
      briefing += `- **Avg duration:** ${(avgDur / 1000).toFixed(1)}s\n\n`;
    }

    // Kronos semantic context (best-effort)
    try {
      const isHealthy = await this.kronos.healthCheck();
      if (isHealthy) {
        const result = await this.kronos.search(
          `${agent} ${taskDescription}`,
          project
        );

        if (result.pointers.length > 0) {
          briefing += `## Relevant Past Patterns (from Kronos)\n\n`;
          for (const pointer of result.pointers) {
            const score = (pointer.relevanceScore * 100).toFixed(0);
            briefing += `- **${pointer.summary}** (${score}% match)\n`;
          }
          briefing += `\n`;
        }
      }
    } catch {
      // Kronos briefing context is optional
    }

    // Recent failures for this agent
    const recentFailures = agentBuilds
      .filter(b => !b.gatesPassed && b.error)
      .slice(-3);

    if (recentFailures.length > 0) {
      briefing += `## Recent Failures to Avoid\n\n`;
      for (const fail of recentFailures) {
        briefing += `- **${fail.taskId}:** ${fail.error}\n`;
      }
      briefing += `\n`;
    }

    return briefing;
  }

  private loadBuilds(): BuildLog[] {
    if (!existsSync(BUILDS_FILE)) {
      return [];
    }
    try {
      const raw = readFileSync(BUILDS_FILE, 'utf-8');
      return JSON.parse(raw) as BuildLog[];
    } catch {
      return [];
    }
  }

  private computeAgentStats(builds: BuildLog[]): AgentStats[] {
    const agentMap = new Map<string, { passed: number; failed: number; totalDuration: number }>();

    for (const build of builds) {
      const existing = agentMap.get(build.agent) || { passed: 0, failed: 0, totalDuration: 0 };
      if (build.gatesPassed) {
        existing.passed++;
      } else {
        existing.failed++;
      }
      existing.totalDuration += build.duration;
      agentMap.set(build.agent, existing);
    }

    const stats: AgentStats[] = [];
    for (const [agent, data] of agentMap) {
      const total = data.passed + data.failed;
      stats.push({
        agent,
        totalTasks: total,
        passedTasks: data.passed,
        failedTasks: data.failed,
        successRate: total > 0 ? data.passed / total : 0,
        avgDuration: total > 0 ? data.totalDuration / total : 0,
      });
    }

    return stats.sort((a, b) => b.totalTasks - a.totalTasks);
  }

  private detectEffectivePatterns(builds: BuildLog[]): EffectivePattern[] {
    // Group successful builds by agent and look for repeated success patterns
    const patterns: EffectivePattern[] = [];
    const agentSuccesses = new Map<string, BuildLog[]>();

    for (const build of builds) {
      if (build.gatesPassed) {
        const existing = agentSuccesses.get(build.agent) || [];
        existing.push(build);
        agentSuccesses.set(build.agent, existing);
      }
    }

    for (const [agent, successes] of agentSuccesses) {
      if (successes.length >= 2) {
        patterns.push({
          name: `${agent} consistent success`,
          description: `${agent} has passed gates ${successes.length} times consistently`,
          agent,
          occurrences: successes.length,
          lastSeen: successes[successes.length - 1].timestamp,
        });
      }
    }

    return patterns;
  }

  private detectFailurePatterns(builds: BuildLog[]): FailurePattern[] {
    const patterns: FailurePattern[] = [];
    const agentFailures = new Map<string, BuildLog[]>();

    for (const build of builds) {
      if (!build.gatesPassed) {
        const existing = agentFailures.get(build.agent) || [];
        existing.push(build);
        agentFailures.set(build.agent, existing);
      }
    }

    for (const [agent, failures] of agentFailures) {
      const severity: 'low' | 'medium' | 'high' =
        failures.length >= 5 ? 'high' : failures.length >= 2 ? 'medium' : 'low';

      patterns.push({
        name: `${agent} gate failures`,
        description: `${agent} has failed gates ${failures.length} times`,
        agent,
        occurrences: failures.length,
        severity,
      });
    }

    return patterns;
  }

  private generateRecommendations(
    agentStats: AgentStats[],
    _effectivePatterns: EffectivePattern[],
    failurePatterns: FailurePattern[]
  ): string[] {
    const recommendations: string[] = [];

    // Flag agents with low success rates
    for (const stat of agentStats) {
      if (stat.successRate < 0.8 && stat.totalTasks >= 3) {
        recommendations.push(
          `${stat.agent} has a ${(stat.successRate * 100).toFixed(0)}% success rate ` +
          `across ${stat.totalTasks} tasks. Consider reviewing its agent template.`
        );
      }
    }

    // Flag high-severity failure patterns
    for (const pattern of failurePatterns) {
      if (pattern.severity === 'high') {
        recommendations.push(
          `High-severity failure pattern: ${pattern.name} ` +
          `(${pattern.occurrences} occurrences). Investigate root cause.`
        );
      }
    }

    // If no specific issues, note that things look good
    if (recommendations.length === 0) {
      recommendations.push('No significant issues detected. System is performing well.');
    }

    return recommendations;
  }

  private saveRetrospective(retro: Retrospective): void {
    if (!existsSync(ATLAS_DIR)) {
      mkdirSync(ATLAS_DIR, { recursive: true });
    }

    const retroFile = join(ATLAS_DIR, 'retrospective.json');
    writeFileSync(retroFile, JSON.stringify(retro, null, 2));
    console.log(`[ATLAS] Retrospective saved to ${retroFile}`);
  }
}
