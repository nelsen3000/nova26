/**
 * Nova26 Model Routing & Speculative Decoding Module
 * KIMI-R22-01 - Speculative Decoder
 */

import { DecodeResult } from './types.js';

/**
 * Configuration for speculative decoding behavior.
 */
export interface SpeculativeDecoderConfig {
  /** Maximum number of draft tokens to generate per step */
  maxDraftTokens: number;
  /** Target acceptance rate for draft tokens (0-1) */
  acceptanceRateTarget: number;
  /** Minimum speedup factor before disabling speculative decoding */
  minSpeedupThreshold: number;
  /** Enable adaptive draft token count based on acceptance rate */
  adaptiveDraftTokens: boolean;
}

/**
 * Default speculative decoder configuration.
 */
const DEFAULT_CONFIG: SpeculativeDecoderConfig = {
  maxDraftTokens: 4,
  acceptanceRateTarget: 0.7,
  minSpeedupThreshold: 1.1,
  adaptiveDraftTokens: true,
};

/**
 * Token verification result from the target model.
 */
interface VerificationResult {
  acceptedTokens: string[];
  rejectedAt: number | null;
  correctedToken: string | null;
}

/**
 * Speculative decoding implementation using a smaller draft model
 * to accelerate inference from a larger target model.
 * 
 * This technique generates K tokens with a fast draft model,
 * then verifies them in parallel with the target model.
 */
export class SpeculativeDecoder {
  private config: SpeculativeDecoderConfig;
  private stats: {
    totalDraftTokens: number;
    totalAcceptedTokens: number;
    totalCalls: number;
    avgAcceptanceRate: number;
  };

  constructor(config: Partial<SpeculativeDecoderConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.stats = {
      totalDraftTokens: 0,
      totalAcceptedTokens: 0,
      totalCalls: 0,
      avgAcceptanceRate: 0,
    };
  }

  /**
   * Performs speculative decoding using a draft model and verification model.
   * 
   * @param prompt - The input prompt for generation
   * @param draftModel - Draft model identifier (smaller, faster)
   * @param verifyModel - Verification model identifier (larger, target)
   * @returns DecodeResult with generated output and statistics
   */
  async decode(
    prompt: string,
    draftModel: string,
    verifyModel: string
  ): Promise<DecodeResult> {
    const startTime = Date.now();
    const outputTokens: string[] = [];
    const allDraftTokens: string[] = [];
    let totalDraftTokens = 0;
    let totalAcceptedTokens = 0;
    let draftTokensPerStep = this.config.maxDraftTokens;

    // Mock generation loop - in production this would call actual models
    const maxIterations = 10;
    let currentPrompt = prompt;

    for (let iteration = 0; iteration < maxIterations; iteration++) {
      // Generate K draft tokens
      const draftTokens = await this.generateDraftTokens(
        currentPrompt,
        draftModel,
        draftTokensPerStep
      );
      allDraftTokens.push(...draftTokens);
      totalDraftTokens += draftTokens.length;

      // Verify draft tokens with target model
      const verification = await this.verifyTokens(
        currentPrompt,
        draftTokens,
        verifyModel
      );

      // Add accepted tokens to output
      outputTokens.push(...verification.acceptedTokens);
      totalAcceptedTokens += verification.acceptedTokens.length;

      // If a token was rejected, add the correction
      if (verification.correctedToken) {
        outputTokens.push(verification.correctedToken);
      }

      // Update prompt for next iteration
      currentPrompt = this.updatePrompt(currentPrompt, outputTokens);

      // Adaptive adjustment of draft token count
      if (this.config.adaptiveDraftTokens) {
        const currentAcceptanceRate = totalAcceptedTokens / totalDraftTokens;
        draftTokensPerStep = this.adjustDraftTokens(
          draftTokensPerStep,
          currentAcceptanceRate
        );
      }

      // Check for completion condition
      if (this.shouldStop(outputTokens)) {
        break;
      }
    }

    const durationMs = Date.now() - startTime;
    const acceptanceRate = this.calculateAcceptanceRate(
      allDraftTokens,
      outputTokens.slice(0, totalAcceptedTokens)
    );
    const speedupFactor = this.getSpeedupFactor(acceptanceRate);

    // Update statistics
    this.updateStats(totalDraftTokens, totalAcceptedTokens);

    return {
      output: outputTokens.join(''),
      tokensGenerated: outputTokens.length,
      draftTokens: totalDraftTokens,
      acceptedTokens: totalAcceptedTokens,
      acceptanceRate,
      speedupFactor,
      durationMs,
    };
  }

  /**
   * Calculates the acceptance rate of draft tokens.
   * 
   * @param draftTokens - Tokens generated by the draft model
   * @param verifiedTokens - Tokens accepted by the verification model
   * @returns Acceptance rate between 0 and 1
   */
  calculateAcceptanceRate(
    draftTokens: string[],
    verifiedTokens: string[]
  ): number {
    if (draftTokens.length === 0) {
      return 0;
    }

    let matches = 0;
    const minLength = Math.min(draftTokens.length, verifiedTokens.length);

    for (let i = 0; i < minLength; i++) {
      if (draftTokens[i] === verifiedTokens[i]) {
        matches++;
      } else {
        break;
      }
    }

    return matches / draftTokens.length;
  }

  /**
   * Calculates the theoretical speedup factor based on acceptance rate.
   * 
   * @param acceptanceRate - Rate of draft token acceptance (0-1)
   * @returns Speedup factor (>1 means faster than baseline)
   */
  getSpeedupFactor(acceptanceRate: number): number {
    // Speedup formula based on speculative decoding theory:
    // S = 1 / (1 - α + α/K) where α is acceptance rate, K is draft tokens
    // Simplified approximation:
    
    if (acceptanceRate <= 0) {
      return 1.0; // No speedup if no acceptance
    }

    const K = this.config.maxDraftTokens;
    const draftSpeedRatio = 3.0; // Draft model is typically 3x faster
    
    // Theoretical speedup calculation
    const verificationCost = 1.0; // Cost of one verification call
    const draftCost = verificationCost / draftSpeedRatio; // Cost per draft token
    
    const expectedAcceptedTokens = acceptanceRate * K;
    const totalCost = draftCost * K + verificationCost;
    const baselineCost = expectedAcceptedTokens; // Cost without speculative decoding

    const speedup = baselineCost / totalCost * draftSpeedRatio;

    // Clamp to reasonable bounds
    return Math.max(1.0, Math.min(speedup, 3.0));
  }

  /**
   * Gets current performance statistics.
   */
  getStats(): {
    totalDraftTokens: number;
    totalAcceptedTokens: number;
    totalCalls: number;
    avgAcceptanceRate: number;
  } {
    return { ...this.stats };
  }

  /**
   * Resets performance statistics.
   */
  resetStats(): void {
    this.stats = {
      totalDraftTokens: 0,
      totalAcceptedTokens: 0,
      totalCalls: 0,
      avgAcceptanceRate: 0,
    };
  }

  /**
   * Determines if speculative decoding is beneficial based on current stats.
   */
  isBeneficial(): boolean {
    if (this.stats.totalCalls === 0) {
      return true; // Default to enabled until we have data
    }
    
    const speedup = this.getSpeedupFactor(this.stats.avgAcceptanceRate);
    return speedup >= this.config.minSpeedupThreshold;
  }

  // Private helper methods

  private async generateDraftTokens(
    prompt: string,
    _draftModel: string,
    count: number
  ): Promise<string[]> {
    // Mock draft token generation
    // In production, this would call the draft model
    return this.mockTokenGeneration(prompt, count);
  }

  private async verifyTokens(
    prompt: string,
    draftTokens: string[],
    _verifyModel: string
  ): Promise<VerificationResult> {
    // Mock token verification
    // In production, this would call the target model in parallel
    const acceptanceRate = 0.7; // Simulated 70% acceptance
    
    const acceptedTokens: string[] = [];
    let rejectedAt: number | null = null;
    let correctedToken: string | null = null;

    for (let i = 0; i < draftTokens.length; i++) {
      if (Math.random() < acceptanceRate) {
        acceptedTokens.push(draftTokens[i]);
      } else {
        rejectedAt = i;
        correctedToken = this.mockCorrectToken(prompt, draftTokens[i]);
        break;
      }
    }

    return { acceptedTokens, rejectedAt, correctedToken };
  }

  private mockTokenGeneration(_prompt: string, count: number): string[] {
    // Generate mock tokens for testing
    const tokens: string[] = [];
    const vocabulary = ['the', 'a', 'is', 'are', 'was', 'were', 'be', 'been',
                       'to', 'of', 'and', 'in', 'that', 'have', 'it', 'for',
                       'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at'];
    
    for (let i = 0; i < count; i++) {
      const randomToken = vocabulary[Math.floor(Math.random() * vocabulary.length)];
      tokens.push(randomToken + (Math.random() > 0.8 ? '.' : ''));
    }
    
    return tokens;
  }

  private mockCorrectToken(_prompt: string, draftToken: string): string {
    // Return a mock correction for rejected tokens
    return draftToken + '_corrected';
  }

  private updatePrompt(prompt: string, generatedTokens: string[]): string {
    return prompt + generatedTokens.join(' ');
  }

  private shouldStop(tokens: string[]): boolean {
    // Stop conditions
    const MAX_TOKENS = 100;
    if (tokens.length >= MAX_TOKENS) {
      return true;
    }

    // Check for end-of-sequence token
    const lastToken = tokens[tokens.length - 1];
    if (lastToken?.includes('.') || lastToken?.includes('</s>')) {
      return true;
    }

    return false;
  }

  private adjustDraftTokens(current: number, acceptanceRate: number): number {
    // Adaptive adjustment: increase tokens if acceptance is high, decrease if low
    if (acceptanceRate > this.config.acceptanceRateTarget + 0.1) {
      return Math.min(current + 1, 8);
    } else if (acceptanceRate < this.config.acceptanceRateTarget - 0.1) {
      return Math.max(current - 1, 1);
    }
    return current;
  }

  private updateStats(draftTokens: number, acceptedTokens: number): void {
    this.stats.totalDraftTokens += draftTokens;
    this.stats.totalAcceptedTokens += acceptedTokens;
    this.stats.totalCalls++;
    
    // Recalculate average acceptance rate
    this.stats.avgAcceptanceRate = 
      this.stats.totalAcceptedTokens / this.stats.totalDraftTokens;
  }
}
