// Native Git Branch/PR Workflow
// Automatic branch creation per PRD build, commits per phase, PR creation on completion

import { execSync } from 'child_process';

export interface GitWorkflowConfig {
  autoCommit: boolean;        // Commit after each phase
  autoPR: boolean;            // Create PR on completion
  branchPrefix: string;       // Branch name prefix
  commitPrefix: string;       // Conventional commit prefix
}

const DEFAULT_CONFIG: GitWorkflowConfig = {
  autoCommit: true,
  autoPR: true,
  branchPrefix: 'nova26/',
  commitPrefix: 'feat',
};

/**
 * Check if we're in a git repository
 */
export function isGitRepo(): boolean {
  try {
    execSync('git rev-parse --git-dir', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if gh CLI is available
 */
export function isGhAvailable(): boolean {
  try {
    execSync('gh --version', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Get current branch name
 */
export function getCurrentBranch(): string {
  return execSync('git branch --show-current', { encoding: 'utf-8' }).trim();
}

/**
 * Get default branch (main or master)
 */
export function getDefaultBranch(): string {
  try {
    const remote = execSync('git remote show origin', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    });
    const match = remote.match(/HEAD branch:\s*(\S+)/);
    return match?.[1] || 'main';
  } catch {
    return 'main';
  }
}

/**
 * Create a feature branch for a PRD build
 */
export function createBranch(prdName: string, config: GitWorkflowConfig = DEFAULT_CONFIG): string {
  if (!isGitRepo()) {
    console.log('Not a git repository, skipping branch creation');
    return getCurrentBranch();
  }

  const safeName = prdName
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);

  const branchName = `${config.branchPrefix}${safeName}`;
  const currentBranch = getCurrentBranch();

  // Don't create if already on a nova branch
  if (currentBranch.startsWith(config.branchPrefix)) {
    console.log(`Already on nova branch: ${currentBranch}`);
    return currentBranch;
  }

  try {
    // Check for uncommitted changes
    const status = execSync('git status --porcelain', { encoding: 'utf-8' }).trim();
    if (status) {
      console.log('Uncommitted changes detected, stashing before branch creation');
      execSync('git stash push -m "nova26-auto-stash"', { stdio: 'pipe' });
    }

    execSync(`git checkout -b "${branchName}"`, { stdio: 'pipe' });
    console.log(`Created branch: ${branchName}`);
    return branchName;
  } catch (error: any) {
    // Branch might already exist
    try {
      execSync(`git checkout "${branchName}"`, { stdio: 'pipe' });
      console.log(`Switched to existing branch: ${branchName}`);
      return branchName;
    } catch {
      console.error(`Failed to create/switch branch: ${error.message}`);
      return currentBranch;
    }
  }
}

/**
 * Commit changes for a completed phase
 */
export function commitPhase(
  taskId: string,
  taskTitle: string,
  agentName: string,
  phase: number,
  config: GitWorkflowConfig = DEFAULT_CONFIG
): boolean {
  if (!isGitRepo() || !config.autoCommit) return false;

  try {
    // Check for changes
    const status = execSync('git status --porcelain', { encoding: 'utf-8' }).trim();
    if (!status) {
      console.log('No changes to commit');
      return false;
    }

    // Stage all changes in .nova/output/
    execSync('git add .nova/output/', { stdio: 'pipe' });

    const message = `${config.commitPrefix}(${agentName.toLowerCase()}): ${taskTitle}\n\nTask: ${taskId}\nPhase: ${phase}\nAgent: ${agentName}\n\nGenerated by NOVA26 Ralph Loop`;

    execSync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { stdio: 'pipe' });
    console.log(`Committed phase ${phase}: ${taskTitle}`);
    return true;
  } catch (error: any) {
    console.error(`Failed to commit: ${error.message}`);
    return false;
  }
}

/**
 * Create a Pull Request on build completion
 */
export function createPR(
  prdName: string,
  taskSummary: string[],
  config: GitWorkflowConfig = DEFAULT_CONFIG
): string | null {
  if (!isGitRepo() || !config.autoPR || !isGhAvailable()) {
    if (!isGhAvailable()) {
      console.log('gh CLI not available, skipping PR creation');
    }
    return null;
  }

  const currentBranch = getCurrentBranch();
  const defaultBranch = getDefaultBranch();

  if (currentBranch === defaultBranch) {
    console.log('On default branch, skipping PR creation');
    return null;
  }

  try {
    // Push branch
    execSync(`git push -u origin "${currentBranch}"`, { stdio: 'pipe' });

    // Build PR body
    const body = [
      '## Summary',
      '',
      `Generated by NOVA26 for PRD: **${prdName}**`,
      '',
      '### Completed Tasks',
      '',
      ...taskSummary.map(t => `- ${t}`),
      '',
      '### Quality Gates',
      '',
      '- All MERCURY validations passed',
      '- Hard limits enforced',
      '- Response validation passed',
      '',
      '---',
      'Generated with [NOVA26](https://github.com/nova26)',
    ].join('\n');

    const title = `feat: ${prdName}`;

    const prUrl = execSync(
      `gh pr create --title "${title.replace(/"/g, '\\"')}" --body "${body.replace(/"/g, '\\"')}" --base "${defaultBranch}"`,
      { encoding: 'utf-8' }
    ).trim();

    console.log(`PR created: ${prUrl}`);
    return prUrl;
  } catch (error: any) {
    console.error(`Failed to create PR: ${error.message}`);
    return null;
  }
}

/**
 * Get git diff summary for current changes
 */
export function getDiffSummary(): string {
  if (!isGitRepo()) return 'Not a git repository';

  try {
    const diffStat = execSync('git diff --stat', { encoding: 'utf-8' }).trim();
    const staged = execSync('git diff --cached --stat', { encoding: 'utf-8' }).trim();
    return [
      staged ? `Staged:\n${staged}` : '',
      diffStat ? `Unstaged:\n${diffStat}` : '',
    ].filter(Boolean).join('\n\n') || 'No changes';
  } catch {
    return 'Unable to get diff';
  }
}

/**
 * Full workflow: create branch → execute → commit phases → create PR
 */
export function initWorkflow(prdName: string, config?: Partial<GitWorkflowConfig>): {
  branch: string;
  commitPhase: (taskId: string, title: string, agent: string, phase: number) => boolean;
  finalize: (taskSummary: string[]) => string | null;
} {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  const branch = createBranch(prdName, cfg);

  return {
    branch,
    commitPhase: (taskId, title, agent, phase) =>
      commitPhase(taskId, title, agent, phase, cfg),
    finalize: (taskSummary) => createPR(prdName, taskSummary, cfg),
  };
}
